
import gdb
import struct
import os

# Constants
GCOV_DATA_MAGIC = 0x67636461 # 'gcda'
GCOV_TAG_FUNCTION = 0x01000000
GCOV_TAG_COUNTER_BASE = 0x01a10000
GCOV_TAG_OBJECT_SUMMARY = 0xa1000000 # Obsolete/Newer? Check GCC ver.

# Assume we only care about counters (arcs)
GCOV_COUNTERS = 8

class GcovDumper:
    def __init__(self):
        self.inferior = gdb.selected_inferior()

    def read_u32(self, addr):
        mem = self.inferior.read_memory(addr, 4)
        return struct.unpack('<I', mem)[0]

    def read_u64(self, addr):
        mem = self.inferior.read_memory(addr, 8)
        return struct.unpack('<Q', mem)[0]

    def read_string(self, ptr):
        if ptr == 0: return ""
        s = ""
        offset = 0
        while True:
            mem = self.inferior.read_memory(ptr + offset, 1)
            b = bytes(mem)[0]
            if b == 0: break
            s += chr(b)
            offset += 1
        return s

    def write_u32(self, f, val):
        f.write(struct.pack('<I', val))

    def write_u64(self, f, val):
        f.write(struct.pack('<Q', val))

    def run(self):
        try:
            master = gdb.parse_and_eval("__gcov_master")
            version = int(master['version'])
            print(f"GCOV Version: {hex(version)}")
            
            # Create build directory if needed (gcda files usually go next to source or in build objects)
            # We will write them to absolute paths found in filename
            
            root = master['root']
            while int(root) != 0:
                self.dump_info_list(root['list'], version)
                root = root['next']
                
            print("GCOV dump completed.")
            gdb.execute("quit") 
        except Exception as e:
            print(f"Error during GCOV dump: {e}")
            # Do not quit so user can see error? 
            # Or quit with error.
            gdb.execute("quit 1")

    def dump_info_list(self, info_ptr, version):
        while int(info_ptr) != 0:
            info = info_ptr.dereference()
            filename = self.read_string(int(info['filename']))
            
            # Map filename to local path if needed?
            # Assuming we are in project root, and filename is absolute or relative.
            # We want to put .gcda files in build directory relative to where .o would be?
            # Or just overwrite/create alongside sources?
            # Usually .gcda goes where .gcno is. .gcno is generated by compiler.
            # If I run coverage report, it expects .gcda next to .gcno.
            # .gcno are in build/CMakeFiles/...
            # "filename" in gcov_info usually points to SOURCE file.
            # But we need to write to the object directory.
            # This is tricky without knowing build layout.
            # Simpler: Write to a "coverage_dump" folder and let the user move them?
            # OR: try to find the match.
            
            # Attempt 1: Just write to build directory mirroring structure?
            # Current CWD is /workspace/test/unity-hw-tests
            # .gcno files are in build/esp-idf/main/CMakeFiles/__idf_main.dir/...
            
            # Let's verify where .gcno files are.
            # For now, just print the filename.
            print(f"Processing: {filename}")
            
            # Dump to a local file
            # Flatten path?
            safe_name = filename.replace("/", "_").replace("\\", "_")
            if safe_name.startswith("_"): safe_name = safe_name[1:]
            # Only dump if it looks like our source
            if "test_entry_gate_hw" in filename or "test_exit_gate_hw" in filename or "test_common" in filename:
                # We need to construct the full .gcda content
                # File: <filename>.gcda
                # But typically it's <source>.gcda
                # I'll just write to safe_name + ".gcda" in current dir for now.
                out_path = f"coverage/{safe_name}.gcda"
                os.makedirs("coverage", exist_ok=True)
                
                with open(out_path, 'wb') as f:
                    self.write_u32(f, GCOV_DATA_MAGIC)
                    self.write_u32(f, version)
                    self.write_u32(f, int(info['stamp']))
                    
                    # Iterate functions
                    n_functions = int(info['n_functions'])
                    functions_array = info['functions'] # pointer to pointer
                    
                    print(f"  Functions: {n_functions}")
                    
                    for i in range(n_functions):
                        fn_info_ptr = (functions_array + i).dereference() # gcov_fn_info*
                        fn_info = fn_info_ptr.dereference()
                        
                        # Function record
                        # Tag: GCOV_TAG_FUNCTION
                        # Length: 2 + (ident, checksum, cfg_checksum) = 2 words? 
                        # WAIT. Length is in words (4 bytes).
                        # Tag (1) + Len (1) + Ident (1) + Lineno_CS (1) + CFG_CS (1) = 5 words total?
                        # No, Tag and Len are header. Len is payload words.
                        # Payload: Ident, Lineno_CS, CFG_CS = 3 words.
                        
                        self.write_u32(f, GCOV_TAG_FUNCTION)
                        self.write_u32(f, 3) # Length
                        self.write_u32(f, int(fn_info['ident']))
                        self.write_u32(f, int(fn_info['lineno_checksum']))
                        self.write_u32(f, int(fn_info['cfg_checksum']))
                        
                        # Counters
                        # ctrs[0] is usually ARCS?
                        # We need to know which counters are active.
                        # info['merge'] array tells us.
                        ctrs = fn_info['ctrs'] # array of gcov_ctr_info
                        
                        # We assume index 0 is ARCS (GCOV_COUNTER_ARCS = 0)
                        # Check if merge[0] is not null?
                        # Assuming yes for standard coverage.
                        
                        # Counter record
                        # Tag: GCOV_TAG_COUNTER_BASE + 0
                        # Length: 2 * num_values
                        ctrs_0 = ctrs[0]
                        num = int(ctrs_0['num'])
                        values_ptr = ctrs_0['values']
                        
                        if num > 0:
                            self.write_u32(f, GCOV_TAG_COUNTER_BASE + 0)
                            self.write_u32(f, num * 2) # Length in words (each value is 64bit = 2 words)
                            
                            for k in range(num):
                                val = self.read_u64(int(values_ptr) + k*8)
                                self.write_u64(f, val)
            
            info = info['next']

    def execute(self):
        # Connect to server
        print("Connecting to Wokwi GDB...")
        gdb.execute("target remote :3333")
        
        # Set breakpoint at the infinite loop in app_main
        # We need to find the line number or use a symbol near the end.
        # "test_app_main.cpp:64" might change.
        # Function `app_main` end.
        # Can we break on `vTaskDelay` call inside the loop?
        # Or easier: breaking on a special function if we had one.
        # But we relied on "Tests Complete" print.
        # We can break on `printf`? No.
        # Let's break on `app_main` and then `finish`? No, it never returns.
        # Break at line 66 (approx).
        gdb.execute("break test_app_main.cpp:66")
        
        print("Running simulation...")
        gdb.execute("continue")
        
        print("Breakpoint hit, dumping data...")
        self.run() # Do the dump

if __name__ == "__main__":
    GcovDumper().execute()

